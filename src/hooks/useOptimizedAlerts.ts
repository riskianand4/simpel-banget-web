import { useState, useEffect, useCallback, useRef } from 'react';
import { AutoAlert } from '@/types/alert-settings';
import { Product } from '@/types/inventory';
import { useToast } from '@/hooks/use-toast';
import { useApp } from '@/contexts/AppContext';
import { createComponentLogger } from '@/utils/logger';
import { globalRequestThrottler } from '@/utils/requestThrottler';

interface OptimizedAlertState {
  alerts: AutoAlert[];
  isGenerating: boolean;
  lastCheck: number;
  error: string | null;
}

// Single source of truth for alert management
export const useOptimizedAlerts = () => {
  const logger = createComponentLogger('OptimizedAlerts');
  const { toast } = useToast();
  const { isAuthenticated, user } = useApp();
  
  const [state, setState] = useState<OptimizedAlertState>({
    alerts: [],
    isGenerating: false,
    lastCheck: 0,
    error: null,
  });
  
  const mountedRef = useRef(true);
  const processingRef = useRef(false);
  const intervalRef = useRef<NodeJS.Timeout | null>(null);

  // Load alerts from localStorage once
  useEffect(() => {
    const saved = localStorage.getItem('optimized-alerts');
    if (saved && state.alerts.length === 0) {
      try {
        const parsedAlerts = JSON.parse(saved).map((alert: any) => ({
          ...alert,
          timestamp: new Date(alert.timestamp),
          acknowledgedAt: alert.acknowledgedAt ? new Date(alert.acknowledgedAt) : undefined,
        }));
        setState(prev => ({ ...prev, alerts: parsedAlerts }));
      } catch {
        localStorage.removeItem('optimized-alerts');
      }
    }
  }, [state.alerts.length]);

  // Generate alerts with strict rate limiting (only for critical alerts)
  const generateAlerts = useCallback(async (products: Product[]) => {
    if (!mountedRef.current || !isAuthenticated || !user || !products?.length) {
      return;
    }

    // Prevent concurrent processing
    if (processingRef.current || state.isGenerating) {
      return;
    }

    // Strict rate limiting: minimum 10 minutes between generations
    const now = Date.now();
    if (now - state.lastCheck < 600000) {
      return;
    }

    // Global request throttling
    if (!globalRequestThrottler.canMakeRequest('optimized-alerts')) {
      return;
    }

    processingRef.current = true;
    setState(prev => ({ ...prev, isGenerating: true, lastCheck: now }));
    globalRequestThrottler.recordRequest('optimized-alerts');

    try {
      const newAlerts: AutoAlert[] = [];
      
      // Get existing unacknowledged alerts to avoid duplicates
      const existingAlertProductIds = new Set(
        state.alerts.filter(alert => !alert.acknowledged).map(alert => alert.productId)
      );

      for (const product of products) {
        if (!mountedRef.current) break;
        
        if (existingAlertProductIds.has(product.id)) {
          continue; // Skip if already has unacknowledged alert
        }

        const stockValue = product.stock;
        let currentStock = 0;

        if (typeof stockValue === 'number') {
          currentStock = stockValue;
        } else if (stockValue && typeof stockValue === 'object') {
          currentStock = (stockValue as any).current || 0;
        }

        // Only generate CRITICAL alerts to reduce noise
        if (currentStock === 0) {
          const newAlert: AutoAlert = {
            id: `optimized-alert-${now}-${product.id}`,
            productId: product.id,
            productName: product.name,
            productCode: product.sku || product.id,
            type: 'out_of_stock',
            severity: 'CRITICAL',
            message: `${product.name} sudah habis!`,
            currentStock: 0,
            totalStock: product.minStock || 100,
            percentage: 0,
            threshold: 0,
            thresholdId: 'critical-out-of-stock',
            acknowledged: false,
            timestamp: new Date(),
            autoGenerated: true,
          };
          
          newAlerts.push(newAlert);
        } else if (currentStock <= 3) { // Very strict threshold for high alerts
          const newAlert: AutoAlert = {
            id: `optimized-alert-${now}-${product.id}`,
            productId: product.id,
            productName: product.name,
            productCode: product.sku || product.id,
            type: 'low_stock',
            severity: 'HIGH',
            message: `${product.name} stock sangat rendah! Tersisa ${currentStock}`,
            currentStock,
            totalStock: product.minStock || 100,
            percentage: Math.round((currentStock / (product.minStock || 100)) * 100),
            threshold: 3,
            thresholdId: 'high-critical-stock',
            acknowledged: false,
            timestamp: new Date(),
            autoGenerated: true,
          };
          
          newAlerts.push(newAlerts.length < 5 ? newAlert : newAlerts[0]); // Limit to 5 alerts per batch
        }
      }

      if (newAlerts.length > 0 && mountedRef.current) {
        setState(prev => {
          const updated = [...prev.alerts, ...newAlerts];
          // Keep only last 15 alerts to prevent memory issues
          const limited = updated.slice(-15);
          localStorage.setItem('optimized-alerts', JSON.stringify(limited));
          return { ...prev, alerts: limited };
        });

        // Show single toast for multiple critical alerts
        const criticalCount = newAlerts.filter(a => a.severity === 'CRITICAL').length;
        if (criticalCount > 0) {
          toast({
            title: "Alert Kritikal!",
            description: criticalCount === 1 
              ? newAlerts[0].message 
              : `${criticalCount} produk habis!`,
            variant: "destructive",
          });
        }

        logger.info(`Generated ${newAlerts.length} new alerts (${criticalCount} critical)`);
      }

    } catch (error) {
      logger.error('Alert generation failed:', error);
      setState(prev => ({ 
        ...prev, 
        error: error instanceof Error ? error.message : 'Alert generation failed' 
      }));
    } finally {
      processingRef.current = false;
      if (mountedRef.current) {
        setState(prev => ({ ...prev, isGenerating: false }));
      }
    }
  }, [state.alerts, state.isGenerating, state.lastCheck, isAuthenticated, user, toast, logger]);

  // Acknowledge alert
  const acknowledgeAlert = useCallback((alertId: string) => {
    setState(prev => {
      const updated = prev.alerts.map(alert =>
        alert.id === alertId
          ? { ...alert, acknowledged: true, acknowledgedBy: user?.name || 'Unknown', acknowledgedAt: new Date() }
          : alert
      );
      localStorage.setItem('optimized-alerts', JSON.stringify(updated));
      return { ...prev, alerts: updated };
    });

    toast({
      title: "Alert Acknowledged",
      description: "Alert berhasil di-acknowledge",
    });
  }, [user, toast]);

  // Clear old alerts periodically
  useEffect(() => {
    const cleanup = () => {
      const cutoffTime = new Date();
      cutoffTime.setHours(cutoffTime.getHours() - 24); // Keep alerts for 24 hours

      setState(prev => {
        const filtered = prev.alerts.filter(alert => 
          alert.timestamp > cutoffTime || !alert.acknowledged
        );
        
        if (filtered.length !== prev.alerts.length) {
          localStorage.setItem('optimized-alerts', JSON.stringify(filtered));
        }
        
        return { ...prev, alerts: filtered };
      });
    };

    const interval = setInterval(cleanup, 60 * 60 * 1000); // Every hour
    return () => clearInterval(interval);
  }, []);

  // Cleanup on unmount
  useEffect(() => {
    return () => {
      mountedRef.current = false;
      processingRef.current = false;
      if (intervalRef.current) {
        clearInterval(intervalRef.current);
      }
    };
  }, []);

  return {
    alerts: state.alerts,
    unacknowledgedAlerts: state.alerts.filter(alert => !alert.acknowledged),
    criticalAlerts: state.alerts.filter(alert => alert.severity === 'CRITICAL' && !alert.acknowledged),
    isGenerating: state.isGenerating,
    error: state.error,
    generateAlerts,
    acknowledgeAlert,
    alertStats: {
      total: state.alerts.length,
      unacknowledged: state.alerts.filter(alert => !alert.acknowledged).length,
      critical: state.alerts.filter(alert => alert.severity === 'CRITICAL' && !alert.acknowledged).length,
    }
  };
};
